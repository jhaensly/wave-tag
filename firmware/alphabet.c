/**
 * @file alphabet.c
 *
 * @author Michael Ciuffo <ch0000f@gmail.com> 24 Jan 2014
 *
 * Font for Wavetag DVT1
 */

#include "alphabet.h"
#include "accel.h"
#include <avr/interrupt.h>
#include "util.h"

/**
 * Matrix of output messages.
 */
volatile uint8_t outputText[MESSAGE_LENGTH]={};

/**
 * Width of display output in pixels.
 */
#define FRAME_BUFFER_LENGTH 10

volatile bool is_wave_active;

/**
 * Pixel framebuffer of current thing to display.
 */
volatile uint8_t frameBuffer [FRAME_BUFFER_LENGTH];

static uint8_t currentLetterLength;

//ignore the first few pulses so you don't prematurely jump into display mode.
static volatile uint8_t ignoreShakes = 2;

/**
 * Location of column "cursor" that is editing the array when adding columns.
*/
static volatile uint8_t frameBufferCursor;

//stores current letter being displayed
static volatile uint8_t messageCursor;

/**
 * Present duration of current vertical column.
 */
static volatile uint8_t columnTimer;

/**
 * Elapsed time of current wave cycle.
 */
static volatile uint32_t waveTimer;

/**
 * The pixel column currently being displayed
 */
static volatile uint8_t currentColumnNumber;

/**
 * Length of time to display each column. Calculated from waveTime.
 */
static volatile uint8_t columnTime;

/**
 * Timeout between accelerometer interrupt and start of message display.
 */
static volatile uint32_t blackoutDelay;


/**
 * Raw pixel data for A-Z, 0-9, and some symbols
 */

static const uint8_t ALPHABET[] PROGMEM = {0,0,0,0,0,0,252,254,51,51,254,252,255,255,219,219,255,102,60,126,231,195,195,102,255,255,195,231,126,60,255,255,219,219,195,255,255,27,27,3,60,126,231,195,211,243,114,255,255,24,24,255,255,195,195,255,255,195,195,48,195,195,195,127,63,255,255,24,124,230,192,255,255,192,192,192,255,255,6,12,6,255,255,255,255,6,28,48,255,255,60,126,195,195,126,60,255,255,51,51,30,12,60,126,195,195,127,188,255,255,51,51,126,236,110,207,201,243,114,3,3,255,255,3,3,127,255,192,192,255,127,63,127,192,192,127,63,255,255,96,48,96,255,255,195,126,24,24,126,195,3,6,252,252,6,3,195,227,243,207,199,195,196,198,255,255,192,192,194,227,243,223,206,66,203,203,255,118,31,31,24,24,255,255,95,219,219,251,115,126,255,203,251,122,227,243,27,15,7,118,255,201,201,255,118,14,95,219,219,126,60,126,255,211,203,255,126,223,223,6,7,211,219,15,14,40,40,254,40,254,40,40,192,192,102,102,38,102,64,64,102,38};

/**
 * Width of each individual symbol
 */
static const uint8_t SYMBOL_LENGTH[] PROGMEM = {6,6,6,6,6,5,5,7,6,6,6,6,5,7,7,6,6,6,6,5,6,6,6,7,6,6,6,6,5,5,6,5,5,5,6,6,6,2,6,7,2,2,6};

/**
 * Location of the beginning of each symbol. Can be generated by a
 * running sum of
 */
static const uint8_t SYMBOL_POSITION[] PROGMEM = {0,6, 12, 18, 24, 30, 35, 40, 47, 53, 59, 65, 71, 76, 83, 90, 96, 102, 108, 114, 119, 125, 131, 137, 144, 150, 156, 162, 168, 173, 178, 184, 189, 194, 199, 205, 211, 217, 219, 225,232,234,236};


/**
* Records current direction of device.  Important because
* accelerometer pin is symmetrical.
*/
static bool goingRight;

/**
* How many hardware interrupts since you last had to reset counters
*/
static uint8_t interruptCount;

/**
 * Add letter to end of frame buffer.
 */
static void addLetter(uint8_t letter)
{
	currentLetterLength = pgm_read_byte(&SYMBOL_LENGTH[letter]);
	uint8_t currentLetterPosition = pgm_read_byte(&SYMBOL_POSITION[letter]);
	uint8_t j;
	for (j=0;j<currentLetterLength;j++)
	{
		frameBuffer[frameBufferCursor]=pgm_read_byte(&ALPHABET[currentLetterPosition+j]);
		frameBufferCursor++;
	}

	//Add gaps between letters
	frameBuffer[frameBufferCursor]=0x00u;
	frameBufferCursor++;
	frameBuffer[frameBufferCursor]=0x00u;
	frameBufferCursor++;
}

/**
 * Regenerate framebuffer from text string.
 */
void refreshFrameBuffer()
{

	//uint8_t i;
	//for(i=0;i<MESSAGE_LENGTH;i++)
	//{
	if (messageCursor<MESSAGE_LENGTH) {
		frameBufferCursor=0;
		///@todo fix this for however we're storing messages
		addLetter(outputText[messageCursor]);
	}
	//while (frameBufferCursor<SIZEOF_ARRAY(frameBuffer))
	//{
	//	frameBuffer[frameBufferCursor]=0xffu;
	//	frameBufferCursor++;
	//}
	//frameBufferCursor = 0;
}

/**
 * Print item from current column of frame buffer to LEDs.
 */
static void printCol(uint8_t col)
{
	OUTPUT_VALUE(frameBuffer[col]);
	return;
}

/**
 * Initialize timers and interrupts required for displaying text.
 */
void initDisplay() {
	///@todo bring this out into a timer .h file

    is_wave_active = true;
	//Timer0 interrupt
	//How high you count
	OCR0A = 0x10u;

	//compare match CTC, no multiplier
	TCCR0A = 0x09u;

	//enable compare match interrupt.
	TIMSK0 = 0x02;

	TCNT0 = 0;

	//Interrupt on INT1. Rising edge.
	EICRA |= 0x0cu;
	//Enable INT1
	EIMSK |= 0x02u;
	sei();
}

/**
* Disable timers used for display.
*/
void killDisplay() {

	//disable compare match interrupt.
	TIMSK0 = 0x00;
	//disable INT1
	EIMSK &= ~0x02u;
	TCNT0 = 0;
	cli();
}



/**
 * Do stuff in timer0 ISR here because AVRdude says you can't do it like a normal person.
 */
void waveTimerZeroHandler() {
    if (++waveTimer >= DISPLAY_SLEEP_TIMEOUT) {
        is_wave_active = false;
    }


    if ((waveTimer>blackoutDelay)&&(messageCursor<MESSAGE_LENGTH))
    {
        //keep ticking until you reach the end of this column
        if (columnTimer < columnTime) {
            columnTimer++;
        }
        else {
            columnTimer = 0;
            //move to next row. +2 handles space between letters
            if (currentColumnNumber < (currentLetterLength))
            {
                currentColumnNumber++;
                printCol(currentColumnNumber);
            }
            else {
                currentColumnNumber=0;
                messageCursor++;
                refreshFrameBuffer();
            }
        }
    }
}

/**
 * Same shit but for external interrupt 1.
 */
void waveIntOneHandler() {


	uint32_t nextWaveTime;







    accel_data_t val;
    accelReadValue(ACCEL_Y, &val);
    if (val>0)
    {
        nextWaveTime = waveTimer;
        blackoutDelay = (nextWaveTime>>2)+(nextWaveTime>>4);
        columnTime = ((nextWaveTime)-(blackoutDelay))/(150);
        waveTimer=0;

        //reset timers once per cycle
        currentColumnNumber = 0;
        messageCursor=0;
        OUTPUT_VALUE(0x00);
        refreshFrameBuffer();

        goingRight=false;
        interruptCount=0;
        columnTimer=0;
    }

	//}
	///@todo clear interrupt flag in case there were any spurious interrupts during this vector
	//GIFR = (1<<PCIF0);

}

