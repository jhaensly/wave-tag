/**
 * @file alphabet.c
 *
 * @author Michael Ciuffo <ch0000f@gmail.com> 24 Jan 2014
 *
 * Font for Wavetag DVT1
 */

#include "alphabet.h"
#include <avr/interrupt.h>
#include "util.h"

/**
 * Matrix of output messages.
 */
volatile uint8_t outputText[8][MESSAGE_LENGTH]={};

/**
 * Width of display output in pixels.
 */
#define FRAME_BUFFER_LENGTH 100

/**
 * Pixel framebuffer of current thing to display.
 */
volatile uint8_t frameBuffer [FRAME_BUFFER_LENGTH];


//ignore the first few pulses so you don't prematurely jump into display mode.
static volatile uint8_t ignoreShakes = 2;

/**
 * Location of column "cursor" that is editing the array when adding columns.
*/
static volatile uint8_t frameBufferCursor;

/**
 * Present duration of current vertical column.
 */
static volatile uint8_t columnTimer;

/**
 * Elapsed time of current wave cycle.
 */
static volatile uint32_t waveTimer;

/**
 * The pixel column currently being displayed
 */
static volatile uint8_t currentColumnNumber;

/**
 * Length of time to display each column. Calculated from waveTime.
 */
static volatile uint8_t columnTime;

/**
 * Timeout between accelerometer interrupt and start of message display.
 */
static volatile uint32_t blackoutDelay;


/**
 * Raw pixel data for A-Z, 0-9, and some symbols
 */
static const uint8_t ALPHABET [242] PROGMEM = {0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0x7f,0xcc,0xcc,0x7f,0x3f,0xff,0xff,0xdb,0xdb,0xff,0x66,0x3c,0x7e,0xe7,0xc3,0xc3,0x66,0xff,0xff,0xc3,0xe7,0x7e,0x3c,0xff,0xff,0xdb,0xdb,0xc3,0xff,0xff,0xd8,0xd8,0xc0,0x3c,0x7e,0xe7,0xc3,0xcb,0xcf,0x4e,0xff,0xff,0x18,0x18,0xff,0xff,0xc3,0xc3,0xff,0xff,0xc3,0xc3,0x0c,0xc3,0xc3,0xc3,0xfe,0xfc,0xff,0xff,0x18,0x3e,0x67,0x03,0xff,0xff,0x03,0x03,0x03,0xff,0xff,0x60,0x30,0x60,0xff,0xff,0xff,0xff,0x60,0x38,0x0c,0xff,0xff,0x3c,0x7e,0xc3,0xc3,0x7e,0x3c,0xff,0xff,0xcc,0xcc,0x78,0x30,0x3c,0x7e,0xc3,0xc3,0xfe,0x3d,0xff,0xff,0xcc,0xcc,0x7e,0x37,0x76,0xf3,0x93,0xcf,0x4e,0xc0,0xc0,0xff,0xff,0xc0,0xc0,0xfe,0xff,0x03,0x03,0xff,0xfe,0xfc,0xfe,0x03,0x03,0xfe,0xfc,0xff,0xff,0x06,0x0c,0x06,0xff,0xff,0xc3,0x7e,0x18,0x18,0x7e,0xc3,0xc0,0x60,0x3f,0x3f,0x60,0xc0,0xc3,0xc7,0xcf,0xf3,0xe3,0xc3,0x23,0x63,0xff,0xff,0x03,0x03,0x43,0xc7,0xcf,0xfb,0x73,0x42,0xd3,0xd3,0xff,0x6e,0xf8,0xf8,0x18,0x18,0xff,0xff,0xfa,0xdb,0xdb,0xdf,0xce,0x7e,0xff,0xd3,0xdf,0x5e,0xc7,0xcf,0xd8,0xf0,0xe0,0x6e,0xff,0x93,0x93,0xff,0x6e,0x70,0xfa,0xdb,0xdb,0x7e,0x3c,0x7e,0xff,0xcb,0xd3,0xff,0x7e,0xfb,0xfb,0x60,0xe0,0xcb,0xdb,0xf0,0x70,0x14,0x14,0x7f,0x14,0x7f,0x14,0x14,0x03,0x03,0x66,0x66,0x64,0x66,0x02,0x02,0x66,0x64};

/**
 * Width of each individual symbol
 */
static const uint8_t SYMBOL_LENGTH[43] PROGMEM = {6,6,6,6,6,5,5,7,6,6,6,6,5,7,7,6,6,6,6,5,6,6,6,7,6,6,6,6,5,5,6,5,5,5,6,6,6,2,6,7,2,2,6};

/**
 * Location of the beginning of each symbol. Can be generated by a
 * running sum of
 */
static const uint8_t SYMBOL_POSITION [43] PROGMEM = {0,6, 12, 18, 24, 30, 35, 40, 47, 53, 59, 65, 71, 76, 83, 90, 96, 102, 108, 114, 119, 125, 131, 137, 144, 150, 156, 162, 168, 173, 178, 184, 189, 194, 199, 205, 211, 217, 219, 225,232,234,236};

/**
 * Add letter to end of frame buffer.
 */
static void addLetter(uint8_t letter)
{
    uint8_t currentLetterLength = pgm_read_byte(&SYMBOL_LENGTH[letter]);
    uint8_t currentLetterPosition = pgm_read_byte(&SYMBOL_POSITION[letter]);
    uint8_t j;
    for (j=0;j<currentLetterLength;j++)
    {
        frameBuffer[frameBufferCursor]=~pgm_read_byte(&ALPHABET[currentLetterPosition+j]);
        frameBufferCursor++;
    }
    
    //Add gaps between letters
    frameBuffer[frameBufferCursor]=0xffu;
    frameBufferCursor++;
    frameBuffer[frameBufferCursor]=0xffu;
    frameBufferCursor++;
}

/**
 * Regenerate framebuffer from text string.
 */
void refreshFrameBuffer()
{
	
	uint8_t i;
	frameBufferCursor=1;
	for(i=0;i<MESSAGE_LENGTH;i++)
	{
        ///@todo fix this for however we're storing messages
        //currently just stores in location zero.
        addLetter(outputText[0][i]);
	}
	while (frameBufferCursor<SIZEOF_ARRAY(frameBuffer))
    {
        frameBuffer[frameBufferCursor]=0xffu;
        frameBufferCursor++;
    }
    frameBufferCursor = 0;
}

/**
 * Print item from current column of frame buffer to LEDs.
 */
static void printCol(uint8_t col)
{
	OUTPUT_VALUE(frameBuffer[col]);
	return;
}

/**
 * Initialize timers and interrupts required for displaying text.
 */
void initDisplay() {
    ///@todo bring this out into a timer .h file
    
    //Timer0 interrupt
    //How high you count
    OCR0A = 0x10u;
    
    //compare match CTC, no multiplier
	TCCR0A = 0x09u;
    
    //enable compare match interrupt.
	TIMSK0 = 0x02;
    
	TCNT0 = 0;
    
    //Interrupt on INT1. Rising edge.
    EICRA = 0x0cu;
    //Enable INT1
    EIMSK = 0x02u;
    
    sei();
}

/**
 * Do stuff in timer0 ISR here because AVRdude says you can't do it like a normal person.
 */
void timerZeroHandler() {
    // Wait before reverting back to menu
    if (waveTimer<displayRefreshTimeout)
        waveTimer++;
    else
    {
        //right before reverting to the menu, reset the shake ignore counter
        if (waveTimer==displayRefreshTimeout)
        {
            ignoreShakes=2;
            waveTimer++; //increment just so ignoreShakes doesn't get called again
        }
        
        ///@todo somehow implement this with whatever menu system we come up with
        //OUTPUT_VALUE(~(1<<messageNumber));
    }
    
    //don't do anything if you're still in the timeout stage before the message
    if (waveTimer>blackoutDelay)
    {
        //keep ticking until you reach the end of this row
        if (columnTimer < columnTime)
        {
            columnTimer++;
        }
        else
        {
            columnTimer = 0;
            //move to next row
            if (currentColumnNumber < (SIZEOF_ARRAY(frameBuffer)-1))
            {
                currentColumnNumber++;
                printCol(currentColumnNumber);
            }
        }
    }

}

/**
 * Same shit but for external interrupt 1.
 */
void intOneHandler() {
    OUTPUT_VALUE(0xff);
    
    uint32_t nextWaveTime;
    
	if (ignoreShakes>0)
		ignoreShakes--;
	else
	{
		//only concern yourself with high-low transitions
		///@todo figure out how to make accelerometer readings assymetrical
		//if (!(PINA&0X80))
		//{
		
        currentColumnNumber = 0;
        printCol(currentColumnNumber);
        nextWaveTime = waveTimer>>1; //allow time for forward and return trip.
        
        //some arbitrary percentage of the total cycle is the timeout.  This allows
        //for the start of the cycle to be at the end of a wave, not in the middle.
        blackoutDelay = (nextWaveTime>>1)+(nextWaveTime>>3);
        
        //divy up the amount of time per cycle by the number of rows you hope to display
        //subtract the timeout to take care of the beginning, and the (mastercount>>4) to tighten up the end a bit.
        columnTime = (nextWaveTime-(nextWaveTime>>4)-(blackoutDelay>>1))/(SIZEOF_ARRAY(frameBuffer));
        
        waveTimer=0;
        
        columnTimer=0;
		//}
	}
    
	///@todo clear interrupt flag in case there were any spurious interrupts during this vector
	//GIFR = (1<<PCIF0);

}

